<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>annotate.today - Image Annotation Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/headroom.js"></script>
    
    <!-- CSS Reset -->
    <style>
        /* Modern CSS Reset */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 
                        "Liberation Mono", "Courier New", monospace;
            line-height: 1.4;
            color: #333;
            background: #f5f5f5;    
        }

        button {
            font: inherit;
            border: none;
            cursor: pointer;
        }
    </style>

    <!-- App Styles -->
    <style>
        #image-container {
            max-width: 100%;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            z-index: 1;
            display: none;
        }

        /* Update header styles */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: white;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            font-size: 13px;
        }

        #site-url {
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 100px;
        }

        #instructions {
            flex: 2;
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            color: #666;
            font-size: 12px;
        }

        .instruction-step {
            color: #2196F3;
            font-weight: 500;
            margin-right: 2px;
        }

        #download-container {
            flex: 1;
            display: flex;
            justify-content: flex-end;
            min-width: 100px;
        }

        /* Adjust main content to account for header */
        #image-container {
            padding-top: 48px; /* Same as header height */
            margin: 0;
        }

        /* Update button style */
        .tool-button {
            background: #2196F3;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .tool-button.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Clean instructions */
        #instructions {
            position: static;
            transform: none;
            background: none;
            padding: 0;
            box-shadow: none;
            transition: none;
        }

        /* Tooltip */
        .cursor-tooltip {
            position: fixed;
            background: rgba(33, 33, 33, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1001;
            transform: translate(15px, 15px);
            transition: opacity 0.2s ease;
        }

        /* Comment styling */
        .comment-box {
            background: #FFF176;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 14px;
            font-family: inherit;
        }

        footer {
            text-align: center;
            margin: 16px;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            font-size: 13px;
        }

        footer:hover {
            opacity: 0.7;
        }

        footer .link {
            color: inherit;
            text-decoration: underline;
        }

        /* Add loading and error message styles */
        .center-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hide elements initially */
        #instructions, footer {
            display: none;
        }

        /* Add modal styles after other styles */
        .edu-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .edu-modal h2 {
            font-size: 20px;
            margin-bottom: 16px;
            color: #333;
        }

        .edu-modal ul {
            text-align: left;
            margin: 16px 0;
            padding-left: 24px;
            color: #666;
        }

        .edu-modal li {
            margin: 8px 0;
        }

        .edu-modal .close-btn {
            background: #2196F3;
            color: white;
            padding: 8px 24px;
            border-radius: 4px;
            margin-top: 16px;
            font-size: 14px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            #header {
                padding: 0 12px;
                height: 40px;  /* Slightly smaller header on mobile */
            }

            #site-url {
                display: none;  /* Hide URL on mobile to save space */
            }

            #instructions {
                flex: 1;
                font-size: 11px;
                gap: 12px;
            }

            .instruction-step {
                display: none;  /* Hide step numbers on mobile */
            }

            #download-container {
                min-width: auto;
            }

            .tool-button {
                padding: 4px 10px;
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div id="header">
        <div id="site-url"><b>annotate.today/?url=YOUR_IMAGE_URL</b></div>
        <div id="instructions">
            <span><span class="instruction-step">1</span> Double-click</span>
            <span><span class="instruction-step">2</span> Add annotation</span>
            <span><span class="instruction-step">3</span> Download</span>
        </div>
        <div id="download-container">
            <button class="tool-button" id="save-tool">Download</button>
        </div>
    </div>

    <div id="loading" class="center-message">
        <div class="loading-spinner"></div>
        Loading image...
    </div>

    <div id="error-message" class="center-message" style="display: none;">
        <p style="margin-bottom: 10px;"></p>
        <button onclick="window.location.href=''" class="tool-button visible" style="background: #666;">
            Try Again
        </button>
    </div>

    <div id="image-container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <footer style="display: none;">
        Made with ‚ù§ by <a href="https://x.com/stas_kulesh" class="link" target="_blank">@stas_kulesh</a> from <a
            href="https://karmabot.chat" class="link" target="_blank">Karma</a>
    </footer>

    <!-- Add modal HTML before the closing body tag -->
    <div id="modal-overlay" class="modal-overlay" style="display: none;"></div>
    <div id="edu-modal" class="edu-modal" style="display: none;">
        <h2 id="modal-title">Welcome to annotate.today!</h2>
        <div id="modal-content">
            <ul>
                <li>Use annotate.today/?url=YOUR_IMAGE_URL</li>
                <li>Double-click anywhere to add annotations</li>
                <li>Download and share</li>
            </ul>
        </div>
        <button class="close-btn" id="modal-close">Close</button>
    </div>

    <script>
        // Initialize variables at the start
        const FALLBACK_IMAGE = 'https://annotate.today/new-landing-page-design.png';
        const PROXY_URLS = [
            'https://annotate.today/proxy?url=',  // main domain
        ];
        let currentProxyIndex = 0;
        let imageUrl;

        // Get URL parameter and handle initial state
        const rawUrl = new URLSearchParams(window.location.search).get('url');
        if (rawUrl) {
            imageUrl = encodeURI(decodeURI(rawUrl));
        }

        const loading = document.getElementById('loading');
        const errorMessage = document.getElementById('error-message');
        const instructions = document.getElementById('instructions');
        const footer = document.querySelector('footer');

        // Move footer inside body
        document.body.appendChild(footer);

        function showError(message) {
            loading.style.display = 'none';
            errorMessage.querySelector('p').textContent = message;
            errorMessage.style.display = 'block';
        }

        // Initialize fabric canvas
        const canvas = new fabric.Canvas('canvas');
        const img = new Image();

        // Improve error handling
        img.onerror = function(error) {
            console.error('Image load error:', error);
            showModal('error');
            // Load fallback image when original image fails
            loadImage(FALLBACK_IMAGE);
        };

        // Pre-load image to get dimensions
        img.onload = function() {
            console.log('Initial image loaded:', {
                width: img.width,
                height: img.height,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
            });

            try {
                // Scale image to fit window width
                const maxWidth = window.innerWidth - 40;
                const scale = maxWidth / img.width;
                console.log('Calculated scale:', scale);
                
                // Verify canvas exists
                if (!canvas || !canvas.getElement()) {
                    throw new Error('Canvas not properly initialized');
                }
                
                // Set canvas size first
                canvas.setWidth(img.width * scale);
                canvas.setHeight(img.height * scale);
                console.log('Canvas size set:', {
                    width: canvas.width,
                    height: canvas.height
                });

                // Create fabric image with additional checks
                fabric.Image.fromURL(imageUrl, function(fabricImg) {
                    console.log('Fabric image created:', fabricImg ? 'success' : 'failed');
                    
                    if (!fabricImg) {
                        showError('Failed to process image. Please try again.');
                        return;
                    }

                    try {
                        // Verify canvas still exists
                        if (!canvas || !canvas.getElement()) {
                            throw new Error('Canvas lost during image processing');
                        }

                        // Scale and set background
                        fabricImg.scale(scale);
                        console.log('Image scaled');

                        // Use callback to ensure background is set
                        canvas.setBackgroundImage(fabricImg, function() {
                            console.log('Background image set');
                            canvas.renderAll();
                            console.log('Canvas rendered');

                            // Only show UI elements if everything succeeded
                            if (canvas && fabricImg && canvas.backgroundImage) {
                                showUIElements();
                                setCommentCursor();
                                console.log('UI elements updated');
                            } else {
                                console.warn('Canvas state incomplete but continuing');
                                // Still show UI if we got this far
                                showUIElements();
                                setCommentCursor();
                            }
                        });
                    } catch (error) {
                        console.error('Error in final setup:', error);
                        // Don't show error if the app is still usable
                        if (!canvas || !canvas.backgroundImage) {
                            showError('Failed to prepare image. Please try again.');
                        }
                    }
                }, { 
                    crossOrigin: 'anonymous',
                    // Add error handler for fabric image loading
                    onError: function() {
                        console.error('Fabric image load error');
                        // Don't show error if the app is still usable
                        if (!canvas || !canvas.backgroundImage) {
                            showError('Failed to load image properly. Please try again.');
                        }
                    }
                });

            } catch (error) {
                console.error('Error in canvas setup:', error);
                // Don't show error if the app is still usable
                if (!canvas || !canvas.getElement()) {
                    showError('Failed to prepare canvas. Please try again.');
                }
            }
        };

        // Debug function
        function logAction(action, details = {}) {
            console.log(`Action: ${action}`, details);
        }

        // Track active tool
        let activeTool = 'comment'; // Always comment mode

        // Function to update toolbar visibility
        function updateToolbarVisibility() {
            const downloadButton = document.getElementById('save-tool');
            const hasAnnotations = canvas.getObjects().length > 0;
            
            if (hasAnnotations) {
                downloadButton.classList.add('visible');
            } else {
                downloadButton.classList.remove('visible');
            }
            logAction('Download button visibility updated', { visible: hasAnnotations });
        }

        // Add tooltip management
        let mouseTimer = null;
        let isTyping = false;

        // Update cursor function to include tooltip
        function setCommentCursor() {
            const cursorEmoji = 'üí¨';
            
            canvas.on('mouse:move', function(options) {
                // Clear existing timer
                if (mouseTimer) {
                    clearTimeout(mouseTimer);
                    mouseTimer = null;
                }
                
                // Remove existing tooltip
                removeTooltip();

                // Check if mouse is over a comment
                const target = options.target;
                const isOverComment = target && target.type === 'textbox';
                
                // Remove old cursor
                const oldCursor = document.querySelector('.custom-cursor');
                if (oldCursor) oldCursor.remove();
                
                // Only show cursor if not over comment and not typing
                if (!isOverComment && !isTyping) {
                    const cursorHtml = `<div style="
                        position: fixed; 
                        left: ${options.e.clientX}px; 
                        top: ${options.e.clientY}px; 
                        transform: translate(-50%, -50%);
                        pointer-events: none;
                        font-size: 24px;
                        z-index: 1000;
                    ">${cursorEmoji}</div>`;
                    
                    const cursorElement = document.createElement('div');
                    cursorElement.className = 'custom-cursor';
                    cursorElement.innerHTML = cursorHtml;
                    document.body.appendChild(cursorElement);
                    
                    canvas.defaultCursor = `${cursorEmoji}, auto`;
                    canvas.hoverCursor = `${cursorEmoji}, auto`;

                    // Set timer for tooltip
                    mouseTimer = setTimeout(() => {
                        if (!isTyping) {
                            showTooltip(options.e.clientX, options.e.clientY);
                        }
                    }, 3000);
                } else {
                    canvas.defaultCursor = 'default';
                    canvas.hoverCursor = 'move';
                }
            });
        }

        // Add tooltip functions
        function showTooltip(x, y) {
            removeTooltip();
            const tooltip = document.createElement('div');
            tooltip.className = 'cursor-tooltip';
            tooltip.textContent = 'Double-click to annotate';
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
            document.body.appendChild(tooltip);
        }

        function removeTooltip() {
            const tooltip = document.querySelector('.cursor-tooltip');
            if (tooltip) tooltip.remove();
        }

        // Update cursor removal to include tooltip
        function removeCustomCursor() {
            const cursor = document.querySelector('.custom-cursor');
            if (cursor) cursor.remove();
            removeTooltip();
            if (mouseTimer) {
                clearTimeout(mouseTimer);
                mouseTimer = null;
            }
        }

        // Track typing state
        canvas.on('text:editing:entered', function() {
            isTyping = true;
            removeTooltip();
        });

        canvas.on('text:editing:exited', function() {
            isTyping = false;
        });

        // Clean up when mouse leaves canvas
        canvas.on('mouse:out', function() {
            removeCustomCursor();
            if (mouseTimer) {
                clearTimeout(mouseTimer);
                mouseTimer = null;
            }
        });

        // Update canvas.on('mouse:dblclick') handler
        canvas.on('mouse:dblclick', function(options) {
            logAction('Canvas double-clicked', { 
                tool: activeTool,
                position: { x: options.e.offsetX, y: options.e.offsetY }
            });

            // Temporarily remove custom cursor while editing
            removeCustomCursor();

            if (activeTool === 'comment') {
                const pointer = canvas.getPointer(options.e);
                const comment = new fabric.Textbox('Add comment here...', {
                    left: pointer.x,
                    top: pointer.y,
                    width: 200,
                    fontSize: 14,
                    fill: '#000000',
                    backgroundColor: '#FFEB3B',
                    padding: 10,
                    cornerStyle: 'circle',
                    cornerColor: '#666',
                    cornerSize: 6,
                    transparentCorners: false,
                    lockScalingX: false,
                    lockScalingY: true,
                    hasControls: true,
                    editingBorderColor: '#666',
                    borderColor: '#666',
                    borderOpacityWhenMoving: 1,
                    selectable: true,
                    fontFamily: 'Arial',
                    hoverCursor: 'move', // Set cursor for when hovering over comment
                });

                canvas.add(comment);
                canvas.setActiveObject(comment);
                comment.enterEditing();
                comment.selectAll();
                logAction('Comment added', { position: pointer });
                
                // Show toolbar when first comment is added
                updateToolbarVisibility();

                // After comment is created, restore cursor
                setCommentCursor();
            }
        });

        // Restore cursor when entering canvas
        canvas.on('mouse:over', function() {
            setCommentCursor();
        });

        // Improve save functionality
        document.getElementById('save-tool').addEventListener('click', async function() {
            logAction('Save clicked');
            try {
                // Get the canvas data
                const dataUrl = canvas.toDataURL({
                    format: 'png',
                    quality: 1,
                    multiplier: 1
                });
                downloadImage(dataUrl);
            } catch (error) {
                console.error('Direct save failed:', error);
                
                // Fallback method: Use browser download
                try {
                    const link = document.createElement('a');
                    link.download = 'annotated-image.png';
                    link.href = imageUrl; // Use original image URL
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    alert('Note: Due to image source restrictions, annotations could not be included in the download. Consider using an image from a CORS-enabled source.');
                } catch (downloadError) {
                    console.error('Fallback save failed:', downloadError);
                    alert('Unable to save image. Please try a different image source.');
                }
            }
        });

        // Helper function to download image
        function downloadImage(dataUrl) {
            const link = document.createElement('a');
            link.download = 'annotated-image.png';
            link.href = dataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Make canvas responsive
        window.addEventListener('resize', function() {
            const maxWidth = window.innerWidth - 40;
            const backgroundImage = canvas.backgroundImage;
            if (backgroundImage) {
                const scale = maxWidth / backgroundImage.width;
                canvas.setWidth(backgroundImage.width * scale);
                canvas.setHeight(backgroundImage.height * scale);
                canvas.renderAll();
            }
        });

        // Update the CSS to reflect double-click behavior
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.title = 'Double-click to add annotation';

        // Update delete handler to hide toolbar when last comment is removed
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const activeObject = canvas.getActiveObject();
                if (activeObject) {
                    logAction('Object deleted', { 
                        type: activeObject.type,
                        position: { x: activeObject.left, y: activeObject.top }
                    });
                    canvas.remove(activeObject);
                    canvas.renderAll();
                    
                    // Hide toolbar if no comments left
                    updateToolbarVisibility();
                }
            }
        });

        // Optional: Prevent backspace from navigating back in browser
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Backspace' && e.target === document.body) {
                e.preventDefault();
            }
        });

        // Initialize toolbar as hidden (since no comments at start)
        updateToolbarVisibility();

        // Initialize Headroom
        const header = document.querySelector("#header");
        const headroom = new Headroom(header, {
            tolerance: 5,
            offset: 80,
            classes: {
                initial: "headroom",
                pinned: "headroom--pinned",
                unpinned: "headroom--unpinned"
            }
        });
        headroom.init();

        // Add styles for headroom transitions
        const dynamicStyles = document.createElement('style');
        dynamicStyles.textContent = `
            .headroom {
                transition: transform 200ms linear;
            }
            .headroom--pinned {
                transform: translateY(0%);
            }
            .headroom--unpinned {
                transform: translateY(-100%);
            }

            #canvas-container {
                display: flex;
                justify-content: center;
                align-items: flex-start;
                min-height: calc(100vh - 48px);
                padding: 20px;
                box-sizing: border-box;
            }
            
            #canvas {
                max-width: 100%;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
        `;
        document.head.appendChild(dynamicStyles);

        // Function to show UI elements
        function showUIElements() {
            instructions.style.display = 'flex';
            footer.style.display = 'block';
        }

        // Add error handling that doesn't block the UI
        window.addEventListener('error', function(e) {
            console.warn('Non-fatal error:', e.error);
            // Don't show error message if the app is still usable
            if (canvas && canvas.backgroundImage) {
                showUIElements();
            }
        });

        // Update the error handling and modal logic
        function showModal(type) {
            const modal = document.getElementById('edu-modal');
            const modalContent = document.getElementById('modal-content');
            const overlay = document.getElementById('modal-overlay');
            
            if (type === 'error') {
                modalContent.innerHTML = `
                    <h3>Unable to load the image</h3>
                    <p>Make sure that YOUR_IMG_URL is correct and the image is accessible.</p>
                    <ul>
                        <li>Use annotate.today/?url=YOUR_IMAGE_URL</li>
                        <li>Double-click anywhere to add annotations</li>
                        <li>Download and share</li>
                    </ul>
                `;
            } else if (type === 'welcome') {
                modalContent.innerHTML = `
                    <h3>Welcome to annotate.today!</h3>
                    <p>Use annotate.today/?url=YOUR_IMAGE_URL</p>
                    <p>Double-click anywhere to add annotations</p>
                    <p>Download and share</p>
                `;
            }
            
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }

        document.getElementById('modal-close').addEventListener('click', function() {
            document.getElementById('edu-modal').style.display = 'none';
            document.getElementById('modal-overlay').style.display = 'none';
        });

        // Update loadImage function to handle proxy failures
        function loadImage(url) {
            if (!url) {
                loadImage(FALLBACK_IMAGE);
                return;
            }
            
            document.getElementById('canvas-container').style.display = 'none';
            loading.style.display = 'block';
            
            const tryLoadImage = (retryCount = 0) => {
                const proxiedUrl = url === FALLBACK_IMAGE ? 
                    url : 
                    PROXY_URLS[currentProxyIndex] + encodeURIComponent(url);
                
                console.log('Trying to load image with proxy:', proxiedUrl);
                
                img.onerror = function(error) {
                    console.error('Image load error:', error);
                    
                    // Try next proxy URL
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_URLS.length;
                    
                    if (retryCount < PROXY_URLS.length) {
                        console.log('Retrying with next proxy...');
                        tryLoadImage(retryCount + 1);
                    } else {
                        console.error('All proxies failed');
                        showModal('error');
                        loading.style.display = 'none';
                        if (url !== FALLBACK_IMAGE) {
                            loadImage(FALLBACK_IMAGE);
                        }
                    }
                };
                
                img.onload = function() {
                    const windowWidth = window.innerWidth - 40;
                    const windowHeight = window.innerHeight - 100;
                    
                    let targetWidth = img.width;
                    let targetHeight = img.height;
                    
                    // Scale image to fit window
                    const scale = windowWidth / img.width;
                    targetWidth = windowWidth;
                    targetHeight = img.height * scale;
                    
                    // Set canvas size
                    canvas.setWidth(targetWidth);
                    canvas.setHeight(targetHeight);
                    
                    // Create fabric image
                    fabric.Image.fromURL(proxiedUrl, function(fabricImg) {
                        fabricImg.scale(scale);
                        canvas.setBackgroundImage(fabricImg, function() {
                            canvas.renderAll();
                            document.getElementById('canvas-container').style.display = 'flex';
                            loading.style.display = 'none';
                            showUIElements();
                            setCommentCursor();
                        });
                    }, { crossOrigin: 'anonymous' });
                };
                
                img.src = proxiedUrl;
            };
            
            tryLoadImage();
        }

        // Initial image load
        if (imageUrl) {
            loadImage(imageUrl);
        } else {
            loadImage(FALLBACK_IMAGE);
        }

        // Add proper resize handling
        let resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() {
                const currentBg = canvas.backgroundImage;
                if (currentBg) {
                    // Store current objects and their relative positions
                    const objects = canvas.getObjects();
                    const objectsData = objects.map(obj => ({
                        left: obj.left / canvas.width,
                        top: obj.top / canvas.height,
                        obj: obj
                    }));
                    
                    // Calculate new dimensions
                    const windowWidth = window.innerWidth - 40;
                    const scale = windowWidth / currentBg.width;
                    
                    // Update canvas size
                    canvas.setWidth(windowWidth);
                    canvas.setHeight(currentBg.height * scale);
                    
                    // Scale background image
                    currentBg.scale(scale);
                    
                    // Update object positions only, maintain original size
                    objectsData.forEach(data => {
                        const obj = data.obj;
                        obj.set({
                            left: data.left * canvas.width,
                            top: data.top * canvas.height,
                        });
                    });
                    
                    // Render the changes
                    canvas.renderAll();
                }
            }, 250); // Debounce resize events
        });

        // Handle touch events for mobile
        let lastTap = 0;
        let touchTimer = null;
        
        canvas.on('touch:longpress', function(options) {
            // Prevent default behavior
            options.e.preventDefault();
            handleDoubleTapOrLongPress(options);
        });
        
        canvas.on('touch:tap', function(options) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            // Clear any existing touch timer
            if (touchTimer) {
                clearTimeout(touchTimer);
            }
            
            if (tapLength < 500 && tapLength > 0) {
                // Double tap detected
                handleDoubleTapOrLongPress(options);
                lastTap = 0;
            } else {
                // Set timer for potential second tap
                lastTap = currentTime;
            }
        });
        
        function handleDoubleTapOrLongPress(options) {
            const pointer = canvas.getPointer(options.e);
            
            // Create comment at touch point
            const comment = new fabric.Textbox('Add comment here...', {
                left: pointer.x,
                top: pointer.y,
                width: 200,
                fontSize: 14,
                fill: '#000000',
                backgroundColor: '#FFEB3B',
                padding: 10,
                cornerStyle: 'circle',
                cornerColor: '#666',
                cornerSize: 6,
                transparentCorners: false,
                lockScalingX: false,
                lockScalingY: true,
                hasControls: true,
                editingBorderColor: '#666',
                borderColor: '#666',
                borderOpacityWhenMoving: 1,
                selectable: true,
                fontFamily: 'Arial',
                hoverCursor: 'move',
            });
            
            canvas.add(comment);
            canvas.setActiveObject(comment);
            comment.enterEditing();
            comment.selectAll();
            
            // Show toolbar when first comment is added
            updateToolbarVisibility();
        }
        
        // Update canvas options for better touch handling
        canvas.set({
            allowTouchScrolling: true,
            stopContextMenu: true,
            fireRightClick: true
        });
        
        // Prevent page zoom on double tap
        document.addEventListener('touchend', function(e) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>